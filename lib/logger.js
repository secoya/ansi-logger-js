// Generated by CoffeeScript 1.7.1
var AnsiLogger, clc, moment, _;

_ = require('underscore');

moment = require('moment');

clc = require('cli-color');


/*
 * Ansi output logger.
 * This controls what should be ouputted to the console,
 * everything is categorized into log levels, so when you set a log level
 * you output from all the selected levels.
 * It is possible to disables colors (some teminals don't support colors).
 * you can also specify that you are only interested in output for a specific
 * log-level, then everything else is not outputted.
 * It is also possible to make the logger silent.
 * @author Brian K. Christensen, Secoya A/S <bkc@secoya.dk>
 */

AnsiLogger = (function() {
  AnsiLogger.prototype.ERROR_MASK = 0x1;

  AnsiLogger.prototype.WARN_MASK = 0x2;

  AnsiLogger.prototype.SUCCESS_MASK = 0x4;

  AnsiLogger.prototype.LOG_MASK = 0x8;

  AnsiLogger.prototype.INFO_MASK = 0x10;

  AnsiLogger.prototype.DEBUG_MASK = 0x20;

  AnsiLogger.prototype.VERBOSE_MASK = 0x40;

  AnsiLogger.prototype.SILENT_LEVEL = 0x0;

  AnsiLogger.prototype.ERROR_LEVEL = AnsiLogger.prototype.SILENT_LEVEL | AnsiLogger.prototype.ERROR_MASK;

  AnsiLogger.prototype.WARN_LEVEL = AnsiLogger.prototype.ERROR_LEVEL | AnsiLogger.prototype.WARN_MASK;

  AnsiLogger.prototype.SUCCESS_LEVEL = AnsiLogger.prototype.WARN_LEVEL | AnsiLogger.prototype.SUCCESS_MASK;

  AnsiLogger.prototype.LOG_LEVEL = AnsiLogger.prototype.SUCCESS_LEVEL | AnsiLogger.prototype.LOG_MASK;

  AnsiLogger.prototype.INFO_LEVEL = AnsiLogger.prototype.LOG_LEVEL | AnsiLogger.prototype.INFO_MASK;

  AnsiLogger.prototype.DEBUG_LEVEL = AnsiLogger.prototype.INFO_LEVEL | AnsiLogger.prototype.DEBUG_MASK;

  AnsiLogger.prototype.VERBOSE_LEVEL = AnsiLogger.prototype.DEBUG_LEVEL | AnsiLogger.prototype.VERBOSE_MASK;

  AnsiLogger.prototype.DEFAULT_COLOR = null;

  AnsiLogger.prototype.LOG_COLOR = AnsiLogger.prototype.DEFAULT_COLOR;

  AnsiLogger.prototype.INFO_COLOR = "blue";

  AnsiLogger.prototype.DEBUG_COLOR = "yellow";

  AnsiLogger.prototype.VERBOSE_COLOR = "magenta";

  AnsiLogger.prototype.WARN_COLOR = "red";

  AnsiLogger.prototype.ERROR_COLOR = ["red", "inverse"];

  AnsiLogger.prototype.SUCCESS_COLOR = "green";

  AnsiLogger.prototype.TITLE_COLOR = "cyan";

  AnsiLogger.prototype.TIME_COLOR = "cyan";


  /*
  	 * Moment.js formats.
  	 * @link http://momentjs.com
   */

  AnsiLogger.prototype.DATE_FORMAT = "YYYY-MM-DD";

  AnsiLogger.prototype.TIME_FORAMT = "HH:mm:ss.SSS";


  /*
  	 * The options object holder.
  	 * This is filled with the default values when the Logger is constructed,
  	 * it can be changed by using the setOptions method.
  	 * @see Logger::setOptions()
  	 * @var Object
   */

  AnsiLogger.prototype.options = null;


  /*
  	 * Constructs a Logger, and sets default option values.
   */

  function AnsiLogger(options) {
    this.options = {
      'silent': false,
      'log-level': AnsiLogger.prototype.LOG_LEVEL,
      'no-colors': false,
      'date': false,
      'group': null,
      'group-color': null
    };
    if (options != null) {
      this.setOptions(options);
    }
  }


  /*
  	 * Sets the options.
  	 * @param Object options
  	 * @return void
   */

  AnsiLogger.prototype.setOptions = function(options) {
    var currentLoglevel, loglevelColor, loglevelStr, opt, val, _ref;
    currentLoglevel = this.options['log-level'];
    _ref = this.options;
    for (opt in _ref) {
      val = _ref[opt];
      if (options[opt] != null) {
        this.options[opt] = options[opt];
      }
    }
    if (!_.isNumber(this.options['log-level'] || this.options['log-level'] > AnsiLogger.prototype.VERBOSE_LEVEL)) {
      this.options['log-level'] = currentLoglevel;
      return this.warn("Invalid log level is trying to be set: " + options['log-level'] + ", aborting...");
    } else if (this.options['log-level'] !== currentLoglevel) {
      loglevelStr = this.resolveLogLevel(this.options['log-level']);
      loglevelColor = AnsiLogger.prototype[loglevelStr + "_COLOR"];
      return this.info("Log levels enabled: " + (this.colorize(loglevelStr, loglevelColor)));
    }
  };


  /*
  	 * Print an info formatted message.
  	 * NB! AnsiLogger::LOG_MASK must be present in log level.
  	 *
  	 * @params mixed [, mixed] [, mixed]...
  	 * @return mixed The first argument is returned
   */

  AnsiLogger.prototype["default"] = function() {
    var msg, _i, _len;
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      msg = arguments[_i];
      this.print(msg, AnsiLogger.prototype.LOG_MASK, AnsiLogger.prototype.LOG_COLOR);
    }
    return arguments[0];
  };


  /*
  	 * @alias Logger::default()
  	 * @see Logger::default()
   */

  AnsiLogger.prototype.log = AnsiLogger.prototype["default"];


  /*
  	 * Print an info formatted message.
  	 * NB! AnsiLogger::INFO_MASK must be present in log level.
  	 *
  	 * @params mixed [, mixed] [, mixed]...
  	 * @return mixed The first argument is returned
   */

  AnsiLogger.prototype.info = function() {
    var msg, _i, _len;
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      msg = arguments[_i];
      this.print(msg, AnsiLogger.prototype.INFO_MASK, AnsiLogger.prototype.INFO_COLOR);
    }
    return arguments[0];
  };


  /*
  	 * Print a debug formatted message.
  	 * NB! AnsiLogger::DEBUG_MASK must be present in log level.
  	 *
  	 * @params mixed [, mixed] [, mixed]...
  	 * @return void
   */

  AnsiLogger.prototype.debug = function() {
    var msg, _i, _len;
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      msg = arguments[_i];
      this.print(msg, AnsiLogger.prototype.DEBUG_MASK, AnsiLogger.prototype.DEBUG_COLOR);
    }
    return arguments[0];
  };


  /*
  	 * Print a verbose formatted message.
  	 * NB! AnsiLogger::VERBOSE_MASK must be present in log level.
  	 *
  	 * @params mixed [, mixed] [, mixed]...
  	 * @return mixed The first argument is returned
   */

  AnsiLogger.prototype.verbose = function() {
    var msg, _i, _len;
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      msg = arguments[_i];
      this.print(msg, AnsiLogger.prototype.VERBOSE_MASK, AnsiLogger.prototype.VERBOSE_COLOR);
    }
    return arguments[0];
  };


  /*
  	 * Print a warning.
  	 * NB! AnsiLogger::WARN_MASK must be present in log level.
  	 *
  	 * @params mixed [, mixed] [, mixed]...
  	 * @return mixed The first argument is returned
   */

  AnsiLogger.prototype.warn = function() {
    var msg, _i, _len;
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      msg = arguments[_i];
      this.print(msg, AnsiLogger.prototype.WARN_MASK, AnsiLogger.prototype.WARN_COLOR);
    }
    return arguments[0];
  };


  /*
  	 * Print an error.
  	 * NB! AnsiLogger::ERROR_MASK must be present in log level.
  	 *
  	 * @params mixed [, mixed] [, mixed]...
  	 * @return mixed The first argument is returned
   */

  AnsiLogger.prototype.error = function() {
    var msg, _i, _len;
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      msg = arguments[_i];
      this.print(msg, AnsiLogger.prototype.ERROR_MASK, AnsiLogger.prototype.ERROR_COLOR);
    }
    return arguments[0];
  };


  /*
  	 * Print a success formatted message.
  	 * NB! AnsiLogger::SUCCESS_MASK must be present in log level.
  	 *
  	 * @params mixed [, mixed] [, mixed]...
  	 * @return mixed The first argument is returned
   */

  AnsiLogger.prototype.success = function() {
    var msg, _i, _len;
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      msg = arguments[_i];
      this.print(msg, AnsiLogger.prototype.SUCCESS_MASK, AnsiLogger.prototype.SUCCESS_COLOR);
    }
    return arguments[0];
  };


  /*
  	 * Print a title formatted message.
  	 * NB! AnsiLogger::LOG_MASK must be present in log level.
  	 *
  	 * @params mixed [, mixed] [, mixed]...
  	 * @return mixed The first argument is returned
   */

  AnsiLogger.prototype.title = function() {
    var msg, _i, _len;
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      msg = arguments[_i];
      this.print(msg, AnsiLogger.prototype.LOG_MASK, AnsiLogger.prototype.TITLE_COLOR);
    }
    return arguments[0];
  };


  /*
  	 * Colorize the message string.
  	 * NB! If no-colors mode is on or no color is given.
  	 * then this method just return the message as it is.
  	 * @param String msg
  	 * @param [ String color ] @link https://github.com/medikoo/cli-color for see the color options.
  	 * @param [ String style ] { 'bold', 'italic', 'underline', 'inverse', 'strike' }. NB! some terminals change color, when using bold.
  	 * @return String The colorized message.
   */

  AnsiLogger.prototype.colorize = function(msg, color, style) {
    var func, _ref;
    if (this.options['no-colors'] || (color == null)) {
      return msg;
    }
    if (_.isArray(color)) {
      _ref = color, color = _ref[0], style = _ref[1];
    }
    if (style != null) {
      func = clc[color][style];
    } else {
      func = clc[color];
    }
    return func(msg);
  };


  /*
  	 * Print to console.
  	 * NB! This will print to the console based on the log level you have enabled.
  	 * @param String msg
  	 * @param [ Number loglevel = AnsiLogger::LOG_MASK ]
  	 * @param [ String|Array color ] @see colorize
  	 * @param [ String style ] @see colorize
  	 *	@return void
   */

  AnsiLogger.prototype.print = function(msg, loglevel, color, style) {
    var fg, fll, handleMultiline, str;
    if (loglevel == null) {
      loglevel = AnsiLogger.prototype.LOG_MASK;
    }
    if ((loglevel & this.options['log-level']) !== loglevel) {
      return;
    }
    handleMultiline = (function(_this) {
      return function(msg, color, style) {
        var m, res, _i, _len, _ref;
        res = [];
        _ref = msg.split("\n");
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          m = _ref[_i];
          res.push(_this.colorize(m, color, style));
        }
        return res.join("\n");
      };
    })(this);
    msg = handleMultiline(msg, color, style);
    str = this.formatTime();
    if ((fg = this.formatGroup()) != null) {
      str += " " + fg;
    }
    if ((fll = this.formatLogLevel(loglevel)) != null) {
      str += " " + fll;
    }
    str += " " + msg.replace(/\n/g, "\n" + str + " ");
    if ((loglevel & AnsiLogger.prototype.ERROR_MASK) === AnsiLogger.prototype.ERROR_MASK) {
      return process.stderr.write(str + "\n");
    } else {
      return process.stdout.write(str + "\n");
    }
  };


  /*
  	 * Format a Date object to string.
  	 * @param [ Date time = new Date ]
  	 * @return String
   */

  AnsiLogger.prototype.formatTime = function(time) {
    if (time == null) {
      time = new Date;
    }
    if (!this.options['date']) {
      return "[" + this.colorize(moment(time).format(AnsiLogger.prototype.TIME_FORAMT), AnsiLogger.prototype.TIME_COLOR) + "]";
    }
    if (this.options['date'] === 'true') {
      return "[" + this.colorize(moment(time).format("" + AnsiLogger.prototype.DATE_FORMAT + " " + AnsiLogger.prototype.TIME_FORAMT), AnsiLogger.prototype.TIME_COLOR) + "]";
    }
    return "[" + this.colorize(moment(time).format(this.options['date']), AnsiLogger.prototype.TIME_COLOR) + "]";
  };


  /*
  	 * Format the loglevel to the console
  	 * @param Number loglevel
  	 * @param String msg
  	 * @return String The formatted loglevel
   */

  AnsiLogger.prototype.formatLogLevel = function(loglevel, msg) {
    var fill, fll, i, loglevelColor, loglevelStr, _i, _j, _len, _ref, _ref1, _results;
    if (this.options['log-level'] === AnsiLogger.prototype.LOG_LEVEL) {
      return msg;
    }
    loglevelStr = this.resolveLogLevel(loglevel);
    fill = "";
    _ref1 = (loglevelStr.length < 6 ? (function() {
      _results = [];
      for (var _j = _ref = loglevelStr.length; _ref <= 6 ? _j <= 6 : _j >= 6; _ref <= 6 ? _j++ : _j--){ _results.push(_j); }
      return _results;
    }).apply(this) : []);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      fill += " ";
    }
    loglevelColor = AnsiLogger.prototype[loglevelStr + "_COLOR"];
    fll = "[" + (this.colorize(loglevelStr, loglevelColor)) + "]" + fill;
    if (msg != null) {
      fll += msg;
    }
    return fll;
  };


  /*
  	 * Format group if any.
  	 * @return String The formatted group
   */

  AnsiLogger.prototype.formatGroup = function() {
    var group, i, pad, padding, _i, _j, _len, _ref, _ref1, _results;
    if (this.options['group'] == null) {
      return null;
    }
    group = this.options['group'].trim();
    pad = this.options['group'].length - group.length;
    padding = "";
    _ref1 = (pad > 0 ? (function() {
      _results = [];
      for (var _j = 0, _ref = pad - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; 0 <= _ref ? _j++ : _j--){ _results.push(_j); }
      return _results;
    }).apply(this) : []);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      padding += " ";
    }
    return "[" + (this.colorize(group, this.options['group-color'])) + "]" + padding;
  };


  /*
  	 * Resolve a string representation of the log-level.
  	 * @param Number loglevel
  	 * @return String
   */

  AnsiLogger.prototype.resolveLogLevel = function(loglevel) {
    switch (loglevel) {
      case AnsiLogger.prototype.ERROR_MASK:
        return "ERROR";
      case AnsiLogger.prototype.WARN_MASK:
        return "WARN";
      case AnsiLogger.prototype.SUCCESS_MASK:
        return "SUCCESS";
      case AnsiLogger.prototype.INFO_MASK:
        return "INFO";
      case AnsiLogger.prototype.DEBUG_MASK:
        return "DEBUG";
      case AnsiLogger.prototype.VERBOSE_MASK:
        return "VERBOSE";
      case AnsiLogger.prototype.LOG_MASK:
        return "LOG";
      default:
        return this.resolveCustomLoglevel(loglevel);
    }
  };


  /*
  	 * Resolves custom loglevel string
  	 * @param Number loglevel
  	 * @return String
   */

  AnsiLogger.prototype.resolveCustomLoglevel = function(loglevel) {
    var level, levelStr, levels, mask, result, _i, _len;
    levels = ["ERROR", "WARN", "SUCCESS", "LOG", "INFO", "DEBUG", "VERBOSE"];
    result = [];
    for (_i = 0, _len = levels.length; _i < _len; _i++) {
      level = levels[_i];
      mask = AnsiLogger.prototype[level + "_MASK"];
      if ((loglevel & mask) === mask) {
        levelStr = this.resolveLogLevel(mask);
        result.push(this.colorize(levelStr, AnsiLogger.prototype[levelStr + "_COLOR"]));
      }
    }
    return result.join(", ");
  };


  /*
  	 * Format types to string, some types make resively calls.
  	 * @param mixed type
  	 * @param [ Number seperator = 0 ]
  	 * @param [ Number depth = 3 ] The max depth of recursive calls.
  	 * @return String formated type.
   */

  AnsiLogger.prototype.formatTypes = function(type, seperator, depth) {
    var cname, fill, i, isFunc, key, str, val, _i, _j, _len, _ref, _ref1, _results;
    if (seperator == null) {
      seperator = 0;
    }
    if (depth == null) {
      depth = 3;
    }
    fill = "";
    _ref1 = (seperator > 0 ? (function() {
      _results = [];
      for (var _j = 0, _ref = seperator - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; 0 <= _ref ? _j++ : _j--){ _results.push(_j); }
      return _results;
    }).apply(this) : []);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      fill += "  ";
    }
    if (_.isNumber(type) || _.isBoolean(type) || _.isUndefined(type) || _.isNull(type)) {
      return "" + fill + type;
    }
    if (_.isString(type)) {
      return "" + fill + "'" + type + "'";
    }
    if (_.isArray(type) && (seperator < depth)) {
      str = "" + fill + "[";
      for (key in type) {
        val = type[key];
        str += " " + (this.formatTypes(val, seperator + 1, depth).trim());
        str += key < type.length - 1 ? "," : " ";
      }
      return "" + str + "]";
    }
    if (_.isObject(type) && ((cname = type.constructor.name) === 'Object') && (seperator < depth)) {
      str = "" + fill + "{";
      for (key in type) {
        val = type[key];
        str += "\n" + fill + "  " + key + ": " + (this.formatTypes(val, seperator + 1, depth).trim());
      }
      if (str.length > fill.length + 1) {
        str += "\n" + fill;
      }
      return "" + str + "}";
    }
    if ((isFunc = _.isFunction(type)) || _.isObject(type)) {
      if (cname === "Error") {
        return "" + fill + type.message;
      }
      if (isFunc && cname !== "Function") {
        return "" + fill + "[Function: " + cname + "]";
      }
      return "" + fill + cname;
    }
    return "" + fill + (typeof type);
  };


  /*
  	 * Format a function call, for the debug level
  	 * NB! if passing arguments the function
  	 *     every argument, gonna be formatted with the formatTypes() function
  	 *     @see Logger::formatTypes()
  	 * @param String functionName
  	 * @param [ Array args = [] ]
  	 * @return void
   */

  AnsiLogger.prototype.formatFunctionCall = function(functionName, args) {
    var a, formattedArgs, _i, _len;
    if (args == null) {
      args = [];
    }
    formattedArgs = [];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      a = args[_i];
      formattedArgs.push(this.formatTypes(a));
    }
    return this.debug(functionName + ("(" + (formattedArgs.join(', ')) + ")"));
  };


  /*
  	 * Format an error, this is typically used, for string formatting an Exception/Error.
  	 * @param mixed err
  	 * @return void
   */

  AnsiLogger.prototype.formatError = function(err) {
    return this.print("  " + this.formatTypes(err).replace(/\n/g, "\n  "), AnsiLogger.prototype.ERROR_MASK, AnsiLogger.prototype.ERROR_COLOR);
  };

  return AnsiLogger;

})();

module.exports = AnsiLogger;
