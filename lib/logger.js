// Generated by CoffeeScript 1.9.3
(function() {
  var AnsiLogger, LogEntry, _, clc, identityTransformer, jsonTransformer, moment, textTransformer;

  _ = require('underscore');

  moment = require('moment');

  clc = require('cli-color');

  LogEntry = (function() {
    function LogEntry() {}

    LogEntry.prototype.levelText = null;

    LogEntry.prototype.levelNumeric = null;

    LogEntry.prototype.timestamp = null;

    LogEntry.prototype.group = null;

    LogEntry.prototype.message = null;

    return LogEntry;

  })();


  /*
   * Transform log [entry] to text output.
   * @param LogEntry entry
   * @return String
   */

  textTransformer = function(entry) {
    var levelText, str;
    str = this.formatTime(entry.timestamp);
    if (entry.group != null) {
      str += " " + this.formatGroup(entry.group);
    }
    if ((entry.levelText != null) && ((levelText = this.formatLogLevel(entry.levelNumeric)) != null)) {
      str += " " + levelText;
    }
    str += " " + entry.message.replace(/\n/g, "\n" + str + " ");
    return str;
  };


  /*
   * Transform log entry to text output.
   * @param LogEntry entry
   * @return String
   */

  jsonTransformer = function(entry) {
    return JSON.stringify(entry);
  };


  /*
   * The identity transformer makes no transformation to the log entry
   * and just returns the [LogEntry] as is.
   * @param LogEntry entry
   * @return LogEntry
   */

  identityTransformer = function(entry) {
    return entry;
  };


  /*
   * Ansi output logger.
   * This controls what should be ouputted to the console,
   * everything is categorized into log levels, so when you set a log level
   * you output from all the selected levels.
   * It is possible to disables colors (some teminals don't support colors).
   * you can also specify that you are only interested in output for a specific
   * log-level, then everything else is not outputted.
   * It is also possible to make the logger silent.
   * @author Brian K. Christensen, Secoya A/S <bkc@secoya.dk>
   */

  AnsiLogger = (function() {
    AnsiLogger.prototype.ERROR_MASK = 0x1;

    AnsiLogger.prototype.WARN_MASK = 0x2;

    AnsiLogger.prototype.SUCCESS_MASK = 0x4;

    AnsiLogger.prototype.LOG_MASK = 0x8;

    AnsiLogger.prototype.INFO_MASK = 0x10;

    AnsiLogger.prototype.DEBUG_MASK = 0x20;

    AnsiLogger.prototype.VERBOSE_MASK = 0x40;

    AnsiLogger.prototype.SILENT_LEVEL = 0x0;

    AnsiLogger.prototype.ERROR_LEVEL = AnsiLogger.prototype.SILENT_LEVEL | AnsiLogger.prototype.ERROR_MASK;

    AnsiLogger.prototype.WARN_LEVEL = AnsiLogger.prototype.ERROR_LEVEL | AnsiLogger.prototype.WARN_MASK;

    AnsiLogger.prototype.SUCCESS_LEVEL = AnsiLogger.prototype.WARN_LEVEL | AnsiLogger.prototype.SUCCESS_MASK;

    AnsiLogger.prototype.LOG_LEVEL = AnsiLogger.prototype.SUCCESS_LEVEL | AnsiLogger.prototype.LOG_MASK;

    AnsiLogger.prototype.INFO_LEVEL = AnsiLogger.prototype.LOG_LEVEL | AnsiLogger.prototype.INFO_MASK;

    AnsiLogger.prototype.DEBUG_LEVEL = AnsiLogger.prototype.INFO_LEVEL | AnsiLogger.prototype.DEBUG_MASK;

    AnsiLogger.prototype.VERBOSE_LEVEL = AnsiLogger.prototype.DEBUG_LEVEL | AnsiLogger.prototype.VERBOSE_MASK;

    AnsiLogger.prototype.LOG_COLOR = clc;

    AnsiLogger.prototype.INFO_COLOR = clc.blue;

    AnsiLogger.prototype.DEBUG_COLOR = clc.yellow;

    AnsiLogger.prototype.VERBOSE_COLOR = clc.magenta;

    AnsiLogger.prototype.WARN_COLOR = clc.red.bold;

    AnsiLogger.prototype.ERROR_COLOR = clc.bgRed.white;

    AnsiLogger.prototype.SUCCESS_COLOR = clc.green;

    AnsiLogger.prototype.TITLE_COLOR = clc.cyan;

    AnsiLogger.prototype.TIME_COLOR = clc.cyan;


    /*
    	 * The options object holder.
    	 * This is filled with the default values when the Logger is constructed,
    	 * it can be changed by using the setOptions method.
    	 * @see Logger::setOptions()
    	 * @var Object
     */

    AnsiLogger.prototype.options = null;


    /*
    	 * Constructs a Logger, and sets default option values.
     */

    function AnsiLogger(options) {
      this.options = {
        'log-level': AnsiLogger.prototype.LOG_LEVEL,
        'no-colors': false,

        /*
        			 * Moment.js formats.
        			 * @link http://momentjs.com
         */
        'timeformat': "HH:mm:ss.SSS",
        'group': null,
        'group-color': null,
        'startup-info': true,
        'transformer': textTransformer,
        'outputters': {
          out: function(msg) {
            return process.stdout.write(msg + "\n");
          },
          err: function(msg) {
            return process.stderr.write(msg + "\n");
          }
        }
      };
      if (options != null) {
        this.setOptions(options);
      }
    }


    /*
    	 * Sets the options.
    	 * @param Object options
    	 * @return void
     */

    AnsiLogger.prototype.setOptions = function(options) {
      var currentLoglevel, loglevelColor, loglevelStr, opt, ref, val;
      if (options.colors != null) {
        this.setColors(options.colors);
      }
      currentLoglevel = this.options['log-level'];
      ref = this.options;
      for (opt in ref) {
        val = ref[opt];
        if (options[opt] != null) {
          this.options[opt] = options[opt];
        }
      }
      if (!_.isNumber(this.options['log-level'] || this.options['log-level'] > AnsiLogger.prototype.VERBOSE_LEVEL)) {
        this.options['log-level'] = currentLoglevel;
        return this.warn("Invalid log level is trying to be set: " + options['log-level'] + ", aborting...");
      } else if (this.options['startup-info'] && this.options['log-level'] !== currentLoglevel) {
        loglevelStr = this.resolveLogLevel(this.options['log-level']);
        loglevelColor = this[loglevelStr + "_COLOR"];
        return this.info("Log levels enabled: " + (this.colorize(loglevelStr, loglevelColor)));
      }
    };


    /*
    	 * Set new colors.
    	 * @param Oject<String, Function> colorMap<levelStr, colorFn>
    	 * @return void
     */

    AnsiLogger.prototype.setColors = function(colorMap) {
      var color, level, ref, results;
      results = [];
      for (level in colorMap) {
        color = colorMap[level];
        if ((ref = (level = level.toUpperCase())) === "LOG" || ref === "INFO" || ref === "DEBUG" || ref === "VERBOSE" || ref === "WARN" || ref === "ERROR" || ref === "SUCCESS" || ref === "TITLE" || ref === "TIME") {
          results.push(this[level + "_COLOR"] = color);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };


    /*
    	 * Print an info formatted message.
    	 * NB! AnsiLogger::LOG_MASK must be present in log level.
    	 *
    	 * @params mixed [, mixed] [, mixed]...
    	 * @return mixed The first argument is returned
     */

    AnsiLogger.prototype["default"] = function() {
      var j, len, msg;
      for (j = 0, len = arguments.length; j < len; j++) {
        msg = arguments[j];
        this.print(msg, AnsiLogger.prototype.LOG_MASK, this.LOG_COLOR);
      }
      return arguments[0];
    };


    /*
    	 * @alias Logger::default()
    	 * @see Logger::default()
     */

    AnsiLogger.prototype.log = AnsiLogger.prototype["default"];


    /*
    	 * Print an info formatted message.
    	 * NB! AnsiLogger::INFO_MASK must be present in log level.
    	 *
    	 * @params mixed [, mixed] [, mixed]...
    	 * @return mixed The first argument is returned
     */

    AnsiLogger.prototype.info = function() {
      var j, len, msg;
      for (j = 0, len = arguments.length; j < len; j++) {
        msg = arguments[j];
        this.print(msg, AnsiLogger.prototype.INFO_MASK, this.INFO_COLOR);
      }
      return arguments[0];
    };


    /*
    	 * Print a debug formatted message.
    	 * NB! AnsiLogger::DEBUG_MASK must be present in log level.
    	 *
    	 * @params mixed [, mixed] [, mixed]...
    	 * @return void
     */

    AnsiLogger.prototype.debug = function() {
      var j, len, msg;
      for (j = 0, len = arguments.length; j < len; j++) {
        msg = arguments[j];
        this.print(msg, AnsiLogger.prototype.DEBUG_MASK, this.DEBUG_COLOR);
      }
      return arguments[0];
    };


    /*
    	 * Print a verbose formatted message.
    	 * NB! AnsiLogger::VERBOSE_MASK must be present in log level.
    	 *
    	 * @params mixed [, mixed] [, mixed]...
    	 * @return mixed The first argument is returned
     */

    AnsiLogger.prototype.verbose = function() {
      var j, len, msg;
      for (j = 0, len = arguments.length; j < len; j++) {
        msg = arguments[j];
        this.print(msg, AnsiLogger.prototype.VERBOSE_MASK, this.VERBOSE_COLOR);
      }
      return arguments[0];
    };


    /*
    	 * Print a warning.
    	 * NB! AnsiLogger::WARN_MASK must be present in log level.
    	 *
    	 * @params mixed [, mixed] [, mixed]...
    	 * @return mixed The first argument is returned
     */

    AnsiLogger.prototype.warn = function() {
      var j, len, msg;
      for (j = 0, len = arguments.length; j < len; j++) {
        msg = arguments[j];
        this.print(msg, AnsiLogger.prototype.WARN_MASK, this.WARN_COLOR);
      }
      return arguments[0];
    };


    /*
    	 * Print an error.
    	 * NB! AnsiLogger::ERROR_MASK must be present in log level.
    	 *
    	 * @params mixed [, mixed] [, mixed]...
    	 * @return mixed The first argument is returned
     */

    AnsiLogger.prototype.error = function() {
      var j, len, msg;
      for (j = 0, len = arguments.length; j < len; j++) {
        msg = arguments[j];
        this.print(msg, AnsiLogger.prototype.ERROR_MASK, this.ERROR_COLOR);
      }
      return arguments[0];
    };


    /*
    	 * Print a success formatted message.
    	 * NB! AnsiLogger::SUCCESS_MASK must be present in log level.
    	 *
    	 * @params mixed [, mixed] [, mixed]...
    	 * @return mixed The first argument is returned
     */

    AnsiLogger.prototype.success = function() {
      var j, len, msg;
      for (j = 0, len = arguments.length; j < len; j++) {
        msg = arguments[j];
        this.print(msg, AnsiLogger.prototype.SUCCESS_MASK, this.SUCCESS_COLOR);
      }
      return arguments[0];
    };


    /*
    	 * Print a title formatted message.
    	 * NB! AnsiLogger::LOG_MASK must be present in log level.
    	 *
    	 * @params mixed [, mixed] [, mixed]...
    	 * @return mixed The first argument is returned
     */

    AnsiLogger.prototype.title = function() {
      var j, len, msg;
      for (j = 0, len = arguments.length; j < len; j++) {
        msg = arguments[j];
        this.print(msg, AnsiLogger.prototype.LOG_MASK, this.TITLE_COLOR);
      }
      return arguments[0];
    };


    /*
    	 * Colorize the message string.
    	 * NB! If no-colors mode is on or no color is given.
    	 * then this method just return the message as it is.
    	 * @param String msg
    	 * @param [ Function color ]
    	 * @return String The colorized message.
     */

    AnsiLogger.prototype.colorize = function(msg, color) {
      if ((color == null) || !process.stdout.isTTY || this.options['no-colors']) {
        return msg;
      }
      return color(msg);
    };


    /*
    	 * Print to console.
    	 * NB! This will print to the console based on the log level you have enabled.
    	 * @param String msg
    	 * @param [ Number loglevel = AnsiLogger::LOG_MASK ]
    	 * @param [ String|Array color ] @see colorize
    	 *	@return void
     */

    AnsiLogger.prototype.print = function(msg, loglevel, color) {
      var entry, handleMultiline;
      if (loglevel == null) {
        loglevel = AnsiLogger.prototype.LOG_MASK;
      }
      if ((loglevel & this.options['log-level']) !== loglevel) {
        return;
      }
      entry = new LogEntry;
      handleMultiline = (function(_this) {
        return function(msg, color) {
          var j, len, m, ref, res;
          res = [];
          if ((msg != null ? msg.split : void 0) == null) {
            msg = "" + msg;
          }
          ref = msg.split("\n");
          for (j = 0, len = ref.length; j < len; j++) {
            m = ref[j];
            res.push(_this.colorize(m, color));
          }
          return res.join("\n");
        };
      })(this);
      entry.timestamp = moment().format(this.options['timeformat']);
      entry.message = handleMultiline(msg, color);
      entry.group = this.options.group;
      entry.levelNumeric = loglevel;
      entry.levelText = this.resolveLogLevel(loglevel);
      if ((loglevel & AnsiLogger.prototype.ERROR_MASK) === AnsiLogger.prototype.ERROR_MASK) {
        return this.options.outputters.err.call(this, this.options.transformer.call(this, entry));
      } else {
        return this.options.outputters.out.call(this, this.options.transformer.call(this, entry));
      }
    };


    /*
    	 * Format a object to string.
    	 * @param String time
    	 * @return String
     */

    AnsiLogger.prototype.formatTime = function(time) {
      return "[" + this.colorize(time, this.TIME_COLOR) + "]";
    };


    /*
    	 * Format the loglevel to the console
    	 * @param Number loglevel
    	 * @return String The formatted loglevel
     */

    AnsiLogger.prototype.formatLogLevel = function(loglevel) {
      var fill, fll, i, j, k, len, loglevelColor, loglevelStr, ref, ref1, results;
      if (this.options['log-level'] === AnsiLogger.prototype.LOG_LEVEL) {
        return null;
      }
      loglevelStr = this.resolveLogLevel(loglevel);
      fill = "";
      ref1 = (loglevelStr.length < 6 ? (function() {
        results = [];
        for (var k = ref = loglevelStr.length; ref <= 6 ? k <= 6 : k >= 6; ref <= 6 ? k++ : k--){ results.push(k); }
        return results;
      }).apply(this) : []);
      for (j = 0, len = ref1.length; j < len; j++) {
        i = ref1[j];
        fill += " ";
      }
      loglevelColor = this[loglevelStr + "_COLOR"];
      fll = "[" + (this.colorize(loglevelStr, loglevelColor)) + "]" + fill;
      return fll;
    };


    /*
    	 * Format group if any.
    	 * @return String The formatted group
     */

    AnsiLogger.prototype.formatGroup = function(group) {
      var groupTrimmed, i, j, k, len, pad, padding, ref, ref1, results;
      groupTrimmed = group.trim();
      pad = groupTrimmed.length - group.length;
      padding = "";
      ref1 = (pad > 0 ? (function() {
        results = [];
        for (var k = 0, ref = pad - 1; 0 <= ref ? k <= ref : k >= ref; 0 <= ref ? k++ : k--){ results.push(k); }
        return results;
      }).apply(this) : []);
      for (j = 0, len = ref1.length; j < len; j++) {
        i = ref1[j];
        padding += " ";
      }
      return "[" + (this.colorize(groupTrimmed, this.options['group-color'])) + "]" + padding;
    };


    /*
    	 * Resolve a string representation of the log-level.
    	 * @param Number loglevel
    	 * @return String
     */

    AnsiLogger.prototype.resolveLogLevel = function(loglevel) {
      switch (loglevel) {
        case AnsiLogger.prototype.ERROR_MASK:
          return "ERROR";
        case AnsiLogger.prototype.WARN_MASK:
          return "WARN";
        case AnsiLogger.prototype.SUCCESS_MASK:
          return "SUCCESS";
        case AnsiLogger.prototype.INFO_MASK:
          return "INFO";
        case AnsiLogger.prototype.DEBUG_MASK:
          return "DEBUG";
        case AnsiLogger.prototype.VERBOSE_MASK:
          return "VERBOSE";
        case AnsiLogger.prototype.LOG_MASK:
          return "LOG";
        default:
          return this.resolveCustomLoglevel(loglevel);
      }
    };


    /*
    	 * Resolves custom loglevel string
    	 * @param Number loglevel
    	 * @return String
     */

    AnsiLogger.prototype.resolveCustomLoglevel = function(loglevel) {
      var j, len, level, levelStr, levels, mask, result;
      levels = ["ERROR", "WARN", "SUCCESS", "LOG", "INFO", "DEBUG", "VERBOSE"];
      result = [];
      for (j = 0, len = levels.length; j < len; j++) {
        level = levels[j];
        mask = AnsiLogger.prototype[level + "_MASK"];
        if ((loglevel & mask) === mask) {
          levelStr = this.resolveLogLevel(mask);
          result.push(this.colorize(levelStr, this[levelStr + "_COLOR"]));
        }
      }
      return result.join(", ");
    };


    /*
    	 * Format types to string, some types make resively calls.
    	 * @param mixed type
    	 * @param [ Number seperator = 0 ]
    	 * @param [ Number depth = 3 ] The max depth of recursive calls.
    	 * @return String formated type.
     */

    AnsiLogger.prototype.formatTypes = function(type, seperator, depth) {
      var cname, fill, i, isFunc, j, k, key, len, ref, ref1, results, str, val;
      if (seperator == null) {
        seperator = 0;
      }
      if (depth == null) {
        depth = 3;
      }
      fill = "";
      ref1 = (seperator > 0 ? (function() {
        results = [];
        for (var k = 0, ref = seperator - 1; 0 <= ref ? k <= ref : k >= ref; 0 <= ref ? k++ : k--){ results.push(k); }
        return results;
      }).apply(this) : []);
      for (j = 0, len = ref1.length; j < len; j++) {
        i = ref1[j];
        fill += "  ";
      }
      if (_.isNumber(type) || _.isBoolean(type) || _.isUndefined(type) || _.isNull(type)) {
        return "" + fill + type;
      }
      if (_.isString(type)) {
        return fill + "'" + type + "'";
      }
      if (_.isArray(type) && (seperator < depth)) {
        str = fill + "[";
        for (key in type) {
          val = type[key];
          str += " " + (this.formatTypes(val, seperator + 1, depth).trim());
          str += key < type.length - 1 ? "," : " ";
        }
        return str + "]";
      }
      if (_.isObject(type) && ((cname = type.constructor.name) === 'Object') && (seperator < depth)) {
        str = fill + "{";
        for (key in type) {
          val = type[key];
          str += "\n" + fill + "  " + key + ": " + (this.formatTypes(val, seperator + 1, depth).trim());
        }
        if (str.length > fill.length + 1) {
          str += "\n" + fill;
        }
        return str + "}";
      }
      if ((isFunc = _.isFunction(type)) || _.isObject(type)) {
        if (cname === "Error") {
          return "" + fill + type.message;
        }
        if (isFunc && cname !== "Function") {
          return fill + "[Function: " + cname + "]";
        }
        return "" + fill + cname;
      }
      return "" + fill + (typeof type);
    };


    /*
    	 * Format a function call, for the debug level
    	 * NB! if passing arguments the function
    	 *     every argument, gonna be formatted with the formatTypes() function
    	 *     @see Logger::formatTypes()
    	 * @param String functionName
    	 * @param [ Array args = [] ]
    	 * @return void
     */

    AnsiLogger.prototype.formatFunctionCall = function(functionName, args) {
      var a, formattedArgs, j, len;
      if (args == null) {
        args = [];
      }
      formattedArgs = [];
      for (j = 0, len = args.length; j < len; j++) {
        a = args[j];
        formattedArgs.push(this.formatTypes(a));
      }
      return this.debug(functionName + ("(" + (formattedArgs.join(', ')) + ")"));
    };


    /*
    	 * Format an error, this is typically used, for string formatting an Exception/Error.
    	 * @param mixed err
    	 * @return void
     */

    AnsiLogger.prototype.formatError = function(err) {
      return this.print("  " + this.formatTypes(err).replace(/\n/g, "\n  "), AnsiLogger.prototype.ERROR_MASK, this.ERROR_COLOR);
    };

    return AnsiLogger;

  })();

  module.exports = AnsiLogger;

  module.exports.identityTransformer = identityTransformer;

  module.exports.jsonTransformer = jsonTransformer;

  module.exports.textTransformer = textTransformer;

}).call(this);
